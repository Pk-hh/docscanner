<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Doc Scanner PWA</title>
  
  <!-- Poppins font -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet" />

  <!-- Tesseract.js for OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>

  <!-- SortableJS for drag-drop reorder -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>

  <style>
    :root {
      --primary-color: #3498db;
      --bg-light: #f5f7fa;
      --bg-dark: #121212;
      --text-dark: #333;
      --text-light: #fff;
      --card-bg: #fff;
      --card-bg-dark: #1e1e1e;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg-light: var(--bg-dark);
        --card-bg: var(--card-bg-dark);
        --text-dark: var(--text-light);
      }
    }

    body {
      margin: 0; padding: 0;
      font-family: 'Poppins', sans-serif;
      background: var(--bg-light);
      color: var(--text-dark);
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      transition: background 0.3s, color 0.3s;
    }

    body.dark-mode {
      background: var(--bg-dark);
      color: var(--text-light);
    }

    .app-header {
      background: var(--primary-color);
      color: white;
      font-weight: 600;
      font-size: 1.5rem;
      text-align: center;
      padding: 1rem;
      user-select: none;
    }

    main {
      flex: 1;
      padding: 10px;
      max-width: 480px;
      margin: 0 auto;
      width: 100%;
    }

    /* Camera & Canvas */
    #video {
      width: 100%;
      border-radius: 12px;
      background: black;
    }

    #canvas {
      display: none;
      width: 100%;
      border-radius: 12px;
      margin-top: 10px;
    }

    /* Crop adjustment overlay */
    #cropOverlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: auto;
      border-radius: 12px;
      touch-action: none;
      user-select: none;
    }

    .scanner-container {
      position: relative;
      margin-bottom: 20px;
    }

    /* Central Scan Button */
    .scan-button {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      border: none;
      background: var(--primary-color);
      color: white;
      font-size: 36px;
      display: block;
      margin: 15px auto;
      cursor: pointer;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      transition: background 0.3s;
    }
    .scan-button:hover {
      background: #2980b9;
    }

    /* Controls below preview */
    .preview-controls {
      display: flex;
      justify-content: space-between;
      margin: 10px 0;
      gap: 8px;
    }

    .preview-controls button {
      flex: 1;
      padding: 10px;
      border-radius: 10px;
      border: none;
      background: #eee;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.3s;
    }
    .preview-controls button:hover {
      background: #ddd;
    }

    body.dark-mode .preview-controls button {
      background: #333;
      color: white;
    }
    body.dark-mode .preview-controls button:hover {
      background: #555;
    }

    /* Pages thumbnails container */
    #pagesContainer {
      display: flex;
      gap: 10px;
      overflow-x: auto;
      padding: 10px 0;
      border-top: 1px solid #ccc;
      border-bottom: 1px solid #ccc;
      user-select: none;
    }
    #pagesContainer img {
      width: 60px;
      height: 80px;
      object-fit: cover;
      border-radius: 8px;
      cursor: grab;
      border: 2px solid transparent;
      transition: border 0.3s;
    }
    #pagesContainer img.selected {
      border-color: var(--primary-color);
    }

    /* Feature & status messages */
    #statusMessage {
      text-align: center;
      margin-top: 10px;
      font-style: italic;
      min-height: 1.5rem;
    }

    /* OCR Text Output */
    #ocrTextOutput {
      white-space: pre-wrap;
      background: #f7f7f7;
      border-radius: 10px;
      padding: 10px;
      max-height: 150px;
      overflow-y: auto;
      font-size: 0.9rem;
      margin-top: 10px;
      border: 1px solid #ccc;
    }
    body.dark-mode #ocrTextOutput {
      background: #222;
      border-color: #444;
      color: white;
    }

    /* Toggle Dark mode button */
    #darkModeToggle {
      position: fixed;
      bottom: 15px;
      right: 15px;
      background: var(--primary-color);
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      color: white;
      font-size: 24px;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      transition: background 0.3s;
      z-index: 999;
    }
    #darkModeToggle:hover {
      background: #2980b9;
    }
  </style>
</head>
<body>
  <div class="app-header">üìÑ Doc Scanner PWA</div>

  <main>
    <div class="scanner-container">
      <video id="video" autoplay playsinline></video>
      <canvas id="canvas"></canvas>
      <canvas id="cropOverlay"></canvas>
      <button class="scan-button" title="Scan Page (voice: 'capture')" aria-label="Scan Page">üì∏</button>

      <div class="preview-controls">
        <button id="btnRotate" title="Rotate Image 90¬∞">üîÑ Rotate</button>
        <button id="btnEnhance" title="Auto Enhance Brightness/Contrast">‚ú® Enhance</button>
        <button id="btnCrop" title="Toggle Manual Crop Adjustment">üìê Crop</button>
        <button id="btnExtractText" title="Extract Text (OCR)">üìù OCR</button>
      </div>

      <div id="ocrTextOutput" aria-live="polite" aria-atomic="true"></div>
    </div>

    <h3>üìë Scanned Pages (Drag to reorder)</h3>
    <div id="pagesContainer" aria-label="Scanned pages thumbnails"></div>

    <button id="btnExportPDF" style="width: 100%; padding: 15px; font-size: 16px; background: var(--primary-color); color: white; border:none; border-radius: 10px; cursor:pointer;" aria-label="Export all pages to PDF">Export to PDF üìÑ</button>

    <div id="statusMessage" aria-live="polite"></div>
  </main>

  <button id="darkModeToggle" aria-label="Toggle dark mode">üåì</button>

  <!-- jsPDF for PDF creation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <script>
    // Globals
    let video = document.getElementById('video');
    let canvas = document.getElementById('canvas');
    let ctx = canvas.getContext('2d');
    let cropCanvas = document.getElementById('cropOverlay');
    let cropCtx = cropCanvas.getContext('2d');
    let scanButton = document.querySelector('.scan-button');
    let btnRotate = document.getElementById('btnRotate');
    let btnEnhance = document.getElementById('btnEnhance');
    let btnCrop = document.getElementById('btnCrop');
    let btnExtractText = document.getElementById('btnExtractText');
    let btnExportPDF = document.getElementById('btnExportPDF');
    let pagesContainer = document.getElementById('pagesContainer');
    let ocrTextOutput = document.getElementById('ocrTextOutput');
    let statusMessage = document.getElementById('statusMessage');
    let darkModeToggle = document.getElementById('darkModeToggle');

    // State
    let capturedPages = []; // { img: ImageDataURL, rotation: int, brightness: float, contrast: float, cropPolygon: [points] }
    let currentEditingIndex = null;
    let manualCropMode = false;
    let cropPolygon = null; // 4 points {x,y} relative to canvas size for cropping
    let dragPointIndex = -1;

    // Setup video stream
    async function setupCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
        video.srcObject = stream;
        await video.play();
      } catch (e) {
        alert('Camera access is required to scan documents: ' + e.message);
      }
    }

    // On load
    window.onload = () => {
      setupCamera();
      setupSortable();
      loadFromStorage();
      initDarkMode();
      setupVoiceCommands();
    };

    // Capture current video frame as image
    scanButton.onclick = () => capturePage();

    // Capture function
    function capturePage() {
      if (video.readyState !== video.HAVE_ENOUGH_DATA) {
        alert("Video not ready");
        return;
      }

      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      // Auto crop (simple center crop fallback)
      cropPolygon = [
        { x: 0, y: 0 },
        { x: canvas.width, y: 0 },
        { x: canvas.width, y: canvas.height },
        { x: 0, y: canvas.height }
      ];

      // Save capture
      let imgData = canvas.toDataURL("image/jpeg", 0.9);
      capturedPages.push({ img: imgData, rotation: 0, brightness: 0, contrast: 0, cropPolygon: cropPolygon });
      currentEditingIndex = capturedPages.length - 1;
      refreshPages();
      statusMessage.textContent = "Page captured!";
      ocrTextOutput.textContent = "";
    }

    // Refresh thumbnails
    function refreshPages() {
      pagesContainer.innerHTML = '';
      capturedPages.forEach((page, i) => {
        let imgEl = document.createElement('img');
        imgEl.src = page.img;
        imgEl.alt = `Page ${i + 1}`;
        imgEl.draggable = false;
        imgEl.onclick = () => {
          currentEditingIndex = i;
          showPageEdit(i);
          highlightSelectedThumbnail(i);
        };
        pagesContainer.appendChild(imgEl);
      });
      highlightSelectedThumbnail(currentEditingIndex);
    }

    function highlightSelectedThumbnail(index) {
      [...pagesContainer.children].forEach((el, i) => {
        if (i === index) el.classList.add('selected');
        else el.classList.remove('selected');
      });
    }

    // Show page editing (rotate, enhance, crop overlay)
    function showPageEdit(index) {
      if (index === null || !capturedPages[index]) return;

      let page = capturedPages[index];
      let img = new Image();
      img.onload = () => {
        // Resize canvas
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Apply rotation + brightness/contrast (basic for demo)
        ctx.save();
        ctx.translate(canvas.width/2, canvas.height/2);
        ctx.rotate(page.rotation * Math.PI / 180);
        ctx.translate(-canvas.width/2, -canvas.height/2);
        ctx.filter = `brightness(${1 + page.brightness}) contrast(${1 + page.contrast})`;
        ctx.drawImage(img, 0, 0);
        ctx.restore();

        // Save back updated img (non destructive here)
        // But we'll update on enhancements and rotate buttons

        if (manualCropMode) {
          cropCanvas.style.display = 'block';
          setupCropOverlay(page.cropPolygon);
        } else {
          cropCanvas.style.display = 'none';
        }
      };
      img.src = page.img;
    }

    // Rotate current page 90deg clockwise
    btnRotate.onclick = () => {
      if (currentEditingIndex === null) return;
      capturedPages[currentEditingIndex].rotation = (capturedPages[currentEditingIndex].rotation + 90) % 360;
      showPageEdit(currentEditingIndex);
      statusMessage.textContent = "Page rotated 90¬∞";
    };

    // Enhance brightness/contrast (simple fixed values for demo)
    btnEnhance.onclick = () => {
      if (currentEditingIndex === null) return;
      let page = capturedPages[currentEditingIndex];
      // Toggle brightness + contrast between 0 and 0.2 for demo
      page.brightness = page.brightness === 0 ? 0.2 : 0;
      page.contrast = page.contrast === 0 ? 0.2 : 0;
      showPageEdit(currentEditingIndex);
      statusMessage.textContent = "Brightness & Contrast toggled";
    };

    // Toggle manual crop mode
    btnCrop.onclick = () => {
      if (currentEditingIndex === null) return;
      manualCropMode = !manualCropMode;
      if (manualCropMode) {
        statusMessage.textContent = "Drag corners to adjust crop";
       
      for (let i = 1; i < polygon.length; i++) {
        cropCtx.lineTo(polygon[i].x, polygon[i].y);
      }
      cropCtx.closePath();
      cropCtx.fill();
      cropCtx.stroke();

      // Draw draggable points
      polygon.forEach((pt, i) => {
        cropCtx.beginPath();
        cropCtx.arc(pt.x, pt.y, 10, 0, 2 * Math.PI);
        cropCtx.fillStyle = 'lime';
        cropCtx.fill();
        cropCtx.strokeStyle = 'darkgreen';
        cropCtx.stroke();
      });
    }

    // Handle dragging corners on crop overlay
    cropCanvas.onpointerdown = (e) => {
      if (!manualCropMode || currentEditingIndex === null) return;
      const rect = cropCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      dragPointIndex = -1;
      const pts = capturedPages[currentEditingIndex].cropPolygon;

      for (let i = 0; i < pts.length; i++) {
        let pt = pts[i];
        if (Math.hypot(pt.x - x, pt.y - y) < 20) {
          dragPointIndex = i;
          break;
        }
      }
      if (dragPointIndex !== -1) {
        cropCanvas.setPointerCapture(e.pointerId);
      }
    };

    cropCanvas.onpointermove = (e) => {
      if (!manualCropMode || currentEditingIndex === null) return;
      if (dragPointIndex === -1) return;
      const rect = cropCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const pts = capturedPages[currentEditingIndex].cropPolygon;
      // Clamp inside canvas
      pts[dragPointIndex].x = Math.min(Math.max(0, x), cropCanvas.width);
      pts[dragPointIndex].y = Math.min(Math.max(0, y), cropCanvas.height);

      setupCropOverlay(pts);
    };

    cropCanvas.onpointerup = (e) => {
      if (!manualCropMode) return;
      dragPointIndex = -1;
      saveCropPolygon();
    };

    // Save crop polygon changes
    function saveCropPolygon() {
      if (currentEditingIndex === null) return;
      // Just keep polygon as is, applied in editing preview (for demo, not real crop)
      // Real crop would require applying mask on image or canvas processing (complex)
      statusMessage.textContent = "Crop polygon saved (visual only)";
      saveToStorage();
    }

    // Save capturedPages to localStorage for persistence
    function saveToStorage() {
      localStorage.setItem('docScannerPages', JSON.stringify(capturedPages));
    }

    // Load from storage
    function loadFromStorage() {
      const stored = localStorage.getItem('docScannerPages');
      if (stored) {
        try {
          capturedPages = JSON.parse(stored);
          if (capturedPages.length) currentEditingIndex = 0;
          refreshPages();
          showPageEdit(currentEditingIndex);
          statusMessage.textContent = "Loaded saved pages";
        } catch {
          capturedPages = [];
        }
      }
    }

    // Dark mode toggle
    function initDarkMode() {
      const savedMode = localStorage.getItem('darkMode');
      if (savedMode === 'enabled') {
        document.body.classList.add('dark-mode');
      } else if (savedMode === 'disabled') {
        document.body.classList.remove('dark-mode');
      } else {
        // Use system preference
        if(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          document.body.classList.add('dark-mode');
        }
      }
    }

    darkModeToggle.onclick = () => {
      document.body.classList.toggle('dark-mode');
      if(document.body.classList.contains('dark-mode')) {
        localStorage.setItem('darkMode', 'enabled');
      } else {
        localStorage.setItem('darkMode', 'disabled');
      }
    };

    // Simple voice commands using Web Speech API
    function setupVoiceCommands() {
      if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        console.log('Voice commands not supported');
        return;
      }
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      const recognition = new SpeechRecognition();
      recognition.lang = 'en-US';
      recognition.continuous = true;
      recognition.interimResults = false;

      recognition.onresult = (event) => {
        const last = event.results.length - 1;
        const command = event.results[last][0].transcript.trim().toLowerCase();
        console.log('Voice command:', command);
        if (command.includes('capture') || command.includes('scan')) {
          scanButton.click();
        } else if (command.includes('export') || command.includes('pdf')) {
          btnExportPDF.click();
        }
      };

      recognition.onerror = (e) => console.error('Voice recognition error', e);
      recognition.onend = () => recognition.start();

      recognition.start();
    }

    // Autosave on page unload
    window.onbeforeunload = () => {
      saveToStorage();
    };
  </script>

  <!-- Service Worker for PWA -->
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js').then(() => {
        console.log('Service Worker registered');
      }).catch(console.error);
    }
  </script>
</body>
</html>
