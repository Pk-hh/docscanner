<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Doc Scanner with Edge Detection</title>
<style>
  /* Same basic styles as before */
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin: 0; padding: 0;
    background: #f5f5f5;
    color: #222;
    display: flex; flex-direction: column;
    align-items: center;
    min-height: 100vh;
  }
  header {
    background: #0078d7;
    color: white;
    width: 100%;
    padding: 1rem;
    font-size: 1.5rem;
    text-align: center;
  }
  #video, #canvasOutput {
    border-radius: 12px;
    max-width: 90vw;
    max-height: 60vh;
    margin-top: 1rem;
    background: black;
    position: relative;
  }
  #canvasOutput {
    position: absolute;
    top: 0; left: 0;
    z-index: 10;
  }
  #container {
    position: relative;
  }
  #captureBtn {
    margin: 1rem;
    background: #0078d7;
    border: none;
    color: white;
    font-size: 1.5rem;
    padding: 1rem 2rem;
    border-radius: 50px;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(0,120,215,0.4);
    transition: background 0.3s;
  }
  #captureBtn:hover {
    background: #005a9e;
  }
  #gallery {
    margin: 1rem;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
  }
  .thumb {
    width: 120px;
    height: 160px;
    object-fit: contain;
    border: 2px solid #0078d7;
    border-radius: 8px;
  }
</style>
</head>
<body>

<header>ðŸ“„ Doc Scanner with Edge Detection</header>

<div id="container">
  <video id="video" autoplay playsinline></video>
  <canvas id="canvasOutput"></canvas>
</div>

<button id="captureBtn">ðŸ“¸ Capture</button>

<div id="gallery"></div>

<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script>
  let video = document.getElementById('video');
  let canvasOutput = document.getElementById('canvasOutput');
  let ctxOutput = canvasOutput.getContext('2d');
  let captureBtn = document.getElementById('captureBtn');
  let gallery = document.getElementById('gallery');
  let streaming = false;

  let capturedImages = [];

  // OpenCV variables
  let srcMat, grayMat, edgesMat;

  // OpenCV ready callback
  function onOpenCvReady() {
    console.log('OpenCV.js is ready');
    startCamera();
  }

  async function startCamera() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false });
      video.srcObject = stream;
      video.play();
      video.onloadedmetadata = () => {
        canvasOutput.width = video.videoWidth;
        canvasOutput.height = video.videoHeight;
        streaming = true;
        startProcessing();
      };
    } catch (e) {
      alert("Camera error: " + e);
    }
  }

  function startProcessing() {
    srcMat = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
    grayMat = new cv.Mat();
    edgesMat = new cv.Mat();

    const process = () => {
      if (!streaming) {
        // clean up
        srcMat.delete();
        grayMat.delete();
        edgesMat.delete();
        return;
      }

      ctxOutput.drawImage(video, 0, 0, canvasOutput.width, canvasOutput.height);
      let imageData = ctxOutput.getImageData(0, 0, canvasOutput.width, canvasOutput.height);
      srcMat.data.set(imageData.data);

      // Convert to grayscale
      cv.cvtColor(srcMat, grayMat, cv.COLOR_RGBA2GRAY);
      // Blur to reduce noise
      cv.GaussianBlur(grayMat, grayMat, new cv.Size(5, 5), 0);
      // Canny edge detection
      cv.Canny(grayMat, edgesMat, 75, 200);

      // Find contours
      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(edgesMat, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

      // Find the biggest 4-point contour (approximate polygon)
      let maxArea = 0;
      let approxCurve = new cv.Mat();
      let biggest = null;
      for (let i = 0; i < contours.size(); ++i) {
        let cnt = contours.get(i);
        let area = cv.contourArea(cnt);
        if (area > 10000) {
          cv.approxPolyDP(cnt, approxCurve, 0.02 * cv.arcLength(cnt, true), true);
          if (approxCurve.rows === 4 && area > maxArea) {
            maxArea = area;
            biggest = approxCurve.clone();
          }
        }
        cnt.delete();
      }

      // Draw polygon if found
      ctxOutput.lineWidth = 4;
      ctxOutput.strokeStyle = 'lime';
      ctxOutput.clearRect(0, 0, canvasOutput.width, canvasOutput.height);
      ctxOutput.drawImage(video, 0, 0, canvasOutput.width, canvasOutput.height);

      if (biggest !== null) {
        // Draw detected document contour
        ctxOutput.beginPath();
        for (let i = 0; i < 4; i++) {
          let point = biggest.data32S.slice(i * 2, i * 2 + 2);
          if (i === 0) ctxOutput.moveTo(point[0], point[1]);
          else ctxOutput.lineTo(point[0], point[1]);
        }
        ctxOutput.closePath();
        ctxOutput.stroke();
      }

      hierarchy.delete();
      contours.delete();
      approxCurve.delete();
      if (biggest) biggest.delete();

      requestAnimationFrame(process);
    };
    process();
  }

  // Helper: Order points for perspective transform
  function orderPoints(pts) {
    // pts: array of 4 [x,y]
    pts.sort((a, b) => a[0] - b[0]);
    let left = pts.slice(0, 2).sort((a, b) => a[1] - b[1]);
    let right = pts.slice(2, 4).sort((a, b) => a[1] - b[1]);

    return [left[0], right[0], right[1], left[1]];
  }

  // Perspective transform and capture
  captureBtn.onclick = () => {
    if (!streaming) return alert("Camera not ready yet");

    ctxOutput.drawImage(video, 0, 0, canvasOutput.width, canvasOutput.height);
    let imgData = ctxOutput.getImageData(0, 0, canvasOutput.width, canvasOutput.height);

    // Convert to cv.Mat
    let src = cv.matFromImageData(imgData);
    let gray = new cv.Mat();
    let edges = new cv.Mat();

    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);
    cv.Canny(gray, edges, 75, 200);

    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

    let maxArea = 0;
    let biggest = null;
    let approxCurve = new cv.Mat();

    for (let i = 0; i < contours.size(); ++i) {
      let cnt = contours.get(i);
      let area = cv.contourArea(cnt);
      if (area > 10000) {
        cv.approxPolyDP(cnt, approxCurve, 0.02 * cv.arcLength(cnt, true), true);
        if (approxCurve.rows === 4 && area > maxArea) {
          maxArea = area;
          biggest = approxCurve.clone();
        }
      }
      cnt.delete();
    }

    if (!biggest) {
      alert("No document detected, capture canceled.");
      src.delete(); gray.delete(); edges.delete();
      contours.delete(); hierarchy.delete(); approxCurve.delete();
      return;
    }

    // Order points
    let points = [];
    for (let i = 0; i < 4; i++) {
      points.push([biggest.data32S[i*2], biggest.data32S[i*2 +1]]);
    }
    let ordered = orderPoints(points);

    // Calculate width and height for output image
    function dist(a, b) {
      return Math.hypot(a[0] - b[0], a[1] - b[1]);
    }
    let widthA = dist(ordered[2], ordered[3]);
    let widthB = dist(ordered[1], ordered[0]);
    let maxWidth = Math.max(widthA, widthB);

    let heightA = dist(ordered[1], ordered[2]);
    let heightB = dist(ordered[0], ordered[3]);
    let maxHeight = Math.max(heightA, heightB);

    // Destination points
    let dstCoords = cv.matFromArray(4, 1, cv.CV_32FC2, [
      0, 0,
      maxWidth -1, 0,
      maxWidth -1, maxHeight -1,
      0, maxHeight -1
    ]);

    let srcCoords = cv.matFromArray(4, 1, cv.CV_32FC2, [
      ordered[0][0], ordered[0][1],
      ordered[1][0], ordered[1][1],
      ordered[2][0], ordered[2][1],
      ordered[3][0], ordered[3][1]
    ]);

    let M = cv.getPerspectiveTransform(srcCoords, dstCoords);
    let warped = new cv.Mat();
    cv.warpPerspective(src, warped, M, new cv.Size(maxWidth, maxHeight));

    // Convert warped mat to canvas image
    let outputCanvas = document.createElement('canvas');
    outputCanvas.width = warped.cols;
    outputCanvas.height = warped.rows;
    let outputCtx = outputCanvas.getContext('2d');
    let imgDataOut = new ImageData(new Uint8ClampedArray(warped.data), warped.cols, warped.rows);
    outputCtx.putImageData(imgDataOut, 0, 0);

    // Create image element
    let img = new Image();
    img.src = outputCanvas.toDataURL('image/png');
    img.className = 'thumb';
    gallery.appendChild(img);
    capturedImages.push(img.src);

    // Cleanup
    src.delete(); gray.delete(); edges.delete();
    contours.delete(); hierarchy.delete();
    approxCurve.delete();
    biggest.delete();
    srcCoords.delete(); dstCoords.delete(); M.delete(); warped.delete();
  };
</script>
</body>
</html>
